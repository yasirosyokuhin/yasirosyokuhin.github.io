<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>クロッシーロード風ゲーム</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #87CEEB;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #gameContainer {
    position: relative;
    width: 100vw;
    height: 90vh; /* 100vhから90vhに変更 - ゲーム画面を少し小さくする */
    margin-bottom: 10vh; /* 下部にコントローラー用のスペースを確保 */
}
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #characterInfo {
            position: absolute;
            top: 40px;
            left: 10px;
            font-size: 18px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #mobileControls {
    position: fixed; /* absoluteからfixedに変更 */
    bottom: 30px; /* 少し上に移動 */
    left: 0;
    width: 100%;
    height: 10vh; /* 高さを確保 */
    display: flex;
    justify-content: center;
    gap: 50px;
    background-color: rgba(255, 255, 255, 0.2); /* 半透明の背景を追加 */
    padding: 10px 0; /* パディングを追加 */
    z-index: 100; /* 重ね順を最前面に */
}
.controlBtn {
    width: 60px;
    height: 60px;
    background-color: rgba(255, 255, 255, 0.7); /* 不透明度を上げる */
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px; /* フォントサイズを大きく */
    user-select: none;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* 影を追加して視認性を高める */
    touch-action: manipulation; /* タッチ操作を最適化 */
}
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #gameComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #restartBtn, #completeRestartBtn {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }

        @media (max-width: 480px) {
    #gameOver h2, #gameComplete h2 {
        font-size: 18px;
        margin: 8px 0;
    }
    
    #gameOver p, #gameComplete p {
        font-size: 14px;
        margin: 6px 0;
    }
    
    #restartBtn, #completeRestartBtn {
        margin-top: 10px;
        padding: 8px 16px;
        font-size: 14px;
    }
}
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="score">スコア: 0</div>
        <div id="characterInfo">キャラクター: 4/12 ウサギ</div>
        <div id="mobileControls">
            <div class="controlBtn" id="leftBtn">←</div>
            <div class="controlBtn" id="upBtn">↑</div>
            <div class="controlBtn" id="rightBtn">→</div>
            <div class="controlBtn" id="downBtn">↓</div>
        </div>
        <div id="gameOver">
            <h2>ゲームオーバー</h2>
            <p>スコア: <span id="finalScore">0</span></p>
            <button id="restartBtn">もう一度プレイ</button>
        </div>
        <div id="gameComplete">
            <h2>ゲームクリア！</h2>
            <p>おめでとうございます！</p>
            <p>すべての干支の動物をクリアしました！</p>
            <p>最終スコア: <span id="completeScore">0</span></p>
            <button id="completeRestartBtn">もう一度プレイ</button>
        </div>
    </div>

    <script>
        // ゲーム設定
const config = {
    gridSize: 40,
    playerSpeed: 40, // グリッドサイズと同じにして一度に1マス移動
    vehicleMinSpeed: 1,
    vehicleMaxSpeed: 2,
    laneCount: 3, // 道路のレーン数
    logMinSpeed: 1,
    logMaxSpeed: 3,
    waterLaneCount: 3,
    railwayLaneCount: 2, // 線路のレーン数を追加
    trainMinSpeed: 2, // 電車の最小速度
    trainMaxSpeed: 3, // 電車の最大速度
    safeLaneHeight: 2,
    whaleChance: 0.3, // クジラが出現する確率
    whaleInterval: 5000 // クジラの出現間隔（ミリ秒）
};

// 干支のキャラクター設定
const zodiacCharacters = [
    { name: "ネズミ", color: "#AAAAAA" }, // 0: ネズミ（灰色）
    { name: "牛", color: "#663300" },     // 1: 牛（茶色）
    { name: "トラ", color: "#FF9900" },   // 2: トラ（オレンジ）
    { name: "ウサギ", color: "#FFFFFF" }, // 3: ウサギ（白）
    { name: "竜", color: "#00AA00" },     // 4: 竜（緑）
    { name: "蛇", color: "#DDAA77" },     // 5: 蛇（薄茶色）
    { name: "馬", color: "#8B4513" },     // 6: 馬（茶色）
    { name: "羊", color: "#FFFFCC" },     // 7: 羊（クリーム色）
    { name: "サル", color: "#CC9966" },   // 8: サル（茶色）
    { name: "鳥", color: "#FF6666" },     // 9: 鳥（赤）
    { name: "犬", color: "#FFCC99" },     // 10: 犬（薄茶色）
    { name: "イノシシ", color: "#663333" } // 11: イノシシ（濃い茶色）
];

// ゲーム状態
let gameState = {
    player: { x: 0, y: 0, width: config.gridSize, height: config.gridSize },
    vehicles: [],
    logs: [],
    trains: [], // 電車の配列を追加
    whales: [],
    lanes: [],
    waterLanes: [],
    railwayLanes: [], // 線路のレーン配列を追加
    safeLanes: [],
    score: 0,
    highScore: 0,
    isGameOver: false,
    isOnLog: false,
    currentLogSpeed: 0,
    isMoving: false, // 移動中かどうかを示すフラグ
    direction: null, // 現在の移動方向
    targetX: 0,      // 移動先のX座標
    targetY: 0,      // 移動先のY座標
    moveProgress: 0,  // 移動の進捗（0～1）
    lastWhaleTime: 0,  // 最後にクジラが出現した時間
    zodiacIndex: 0    // 現在の干支のインデックス（0: ネズミから始まる）
};

// キャンバスのセットアップ
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let canvasWidth, canvasHeight;

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    canvasWidth = canvas.width;
    canvasHeight = canvas.height;
    
    // プレイヤーの位置を再設定
    gameState.player.x = Math.floor(canvasWidth / 2 - config.gridSize / 2);
    gameState.player.y = canvasHeight - config.gridSize * 2;
    
    // レーンを再生成
    generateLanes();
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// キー入力の処理
const keys = {};
window.addEventListener('keydown', (e) => {
    if (gameState.isGameOver) {
        if (e.key === 'Enter') {
            restart();
            return;
        }
    }
    
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || 
        e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        e.preventDefault(); // デフォルトのスクロール動作を防止
        keys[e.key] = true;
        startMovement(e.key.replace('Arrow', '').toLowerCase());
    }
});

window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
});

window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
});

// モバイルコントロール
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const upBtn = document.getElementById('upBtn');
const downBtn = document.getElementById('downBtn');

leftBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (!gameState.isMoving) startMovement('left');
});
rightBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (!gameState.isMoving) startMovement('right');
});
upBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (!gameState.isMoving) startMovement('up');
});
downBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (!gameState.isMoving) startMovement('down');
});

// ゲームオーバー処理
function gameOver() {
    gameState.isGameOver = true;
    // 丸太に関する状態をリセット
    gameState.isOnLog = false;
    gameState.currentLogSpeed = 0;
    
    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
    }
    
    document.getElementById('finalScore').textContent = gameState.score;
    document.getElementById('gameOver').style.display = 'block';
}

// 移動処理の開始
function startMovement(direction) {
    if (gameState.isGameOver) return;
    
    // 移動中なら新しい入力を無視するのではなく、現在の移動をキャンセルして新しい方向へ動くように変更
    gameState.isMoving = true;
    gameState.direction = direction;
    gameState.moveProgress = 0;
    
    // 現在位置を保存（移動中だった場合は現在の実際の座標を使用）
    const startX = gameState.player.x;
    const startY = gameState.player.y;
    
    // 移動先を計算
    switch (direction) {
        case 'left':
            gameState.targetX = Math.max(0, startX - config.gridSize);
            gameState.targetY = startY;
            break;
        case 'right':
            gameState.targetX = Math.min(canvasWidth - gameState.player.width, startX + config.gridSize);
            gameState.targetY = startY;
            break;
        case 'up':
            gameState.targetX = startX;
            gameState.targetY = Math.max(0, startY - config.gridSize);
            break;
        case 'down':
            gameState.targetX = startX;
            gameState.targetY = Math.min(canvasHeight - gameState.player.height, startY + config.gridSize);
            break;
    }
}

// 色を生成する関数
function getRandomColor() {
    const colors = ['#FF5733', '#33FF57', '#3357FF', '#F3FF33', '#FF33F3', '#33FFF3'];
    return colors[Math.floor(Math.random() * colors.length)];
}

// 車種のタイプを取得する関数
function getRandomCarType() {
    const types = ['sedan', 'suv', 'truck', 'bus'];
    return types[Math.floor(Math.random() * types.length)];
}

// 電車のタイプを取得する関数
function getRandomTrainType() {
    const types = ['passenger', 'freight', 'express', 'bullet'];
    return types[Math.floor(Math.random() * types.length)];
}

// レーンの生成
function generateLanes() {
    gameState.lanes = [];
    gameState.waterLanes = [];
    gameState.railwayLanes = [];
    gameState.safeLanes = [];
    gameState.whales = [];
    
    // 安全地帯（スタート地点）
    for (let i = 0; i < config.safeLaneHeight; i++) {
        const y = canvasHeight - (i + 1) * config.gridSize;
        gameState.safeLanes.push({ y, type: 'safe' });
        gameState.lanes.push({ y, type: 'safe' });
    }
    
    // 車両レーン
    for (let i = 0; i < config.laneCount; i++) {
        const y = canvasHeight - (config.safeLaneHeight + i + 1) * config.gridSize;
        const direction = Math.random() > 0.5 ? 1 : -1;
        
        // 1列目（i=0）の車の速度を遅くする
        let speed;
        if (i === 0) {
            speed = direction * (config.vehicleMinSpeed + Math.random() * 2); // 最大でも最小速度+2までに制限
        } else {
            speed = direction * (config.vehicleMinSpeed + Math.random() * (config.vehicleMaxSpeed - config.vehicleMinSpeed));
        }
        
        gameState.lanes.push({ y, type: 'road', speed, direction });
    }
    
    // 安全地帯（中間地点）
    const middleSafeY = canvasHeight - (config.safeLaneHeight + config.laneCount + 1) * config.gridSize;
    gameState.safeLanes.push({ y: middleSafeY, type: 'safe' });
    gameState.lanes.push({ y: middleSafeY, type: 'safe' });
    
    // 水レーン
    for (let i = 0; i < config.waterLaneCount; i++) {
        const y = middleSafeY - (i + 1) * config.gridSize;
        const direction = Math.random() > 0.5 ? 1 : -1;
        const speed = direction * (config.logMinSpeed + Math.random() * (config.logMaxSpeed - config.logMinSpeed));
        
        gameState.waterLanes.push({ y, speed, direction });
        gameState.lanes.push({ y, type: 'water', speed, direction });
    }
    
    // 安全地帯（水と線路の間）
    const waterEndY = middleSafeY - (config.waterLaneCount + 1) * config.gridSize;
    gameState.safeLanes.push({ y: waterEndY, type: 'safe' });
    gameState.lanes.push({ y: waterEndY, type: 'safe' });
    
    // 線路レーン
    for (let i = 0; i < config.railwayLaneCount; i++) {
        const y = waterEndY - (i + 1) * config.gridSize;
        const direction = Math.random() > 0.5 ? 1 : -1;
        const speed = direction * (config.trainMinSpeed + Math.random() * (config.trainMaxSpeed - config.trainMinSpeed));
        
        gameState.railwayLanes.push({ y, speed, direction });
        gameState.lanes.push({ y, type: 'railway', speed, direction });
    }
    
    // 安全地帯（ゴール地点）
    const goalY = waterEndY - (config.railwayLaneCount + 1) * config.gridSize;
    gameState.safeLanes.push({ y: goalY, type: 'goal' });
    gameState.lanes.push({ y: goalY, type: 'goal' });
    
    // 車両の生成
    gameState.vehicles = [];
    gameState.lanes.forEach(lane => {
        if (lane.type === 'road') {
            const count = 1 + Math.floor(Math.random() * 3);
            for (let i = 0; i < count; i++) {
                const width = config.gridSize * (1 + Math.floor(Math.random() * 2));
                let x;
                if (lane.direction > 0) {
                    x = -width - Math.random() * canvasWidth * 0.5;
                } else {
                    x = canvasWidth + Math.random() * canvasWidth * 0.5;
                }
                const spacing = canvasWidth / count;
                x += i * spacing;
                
                gameState.vehicles.push({
                    x,
                    y: lane.y,
                    width,
                    height: config.gridSize * 0.8,
                    speed: lane.speed,
                    color: getRandomColor(),
                    type: getRandomCarType()
                });
            }
        }
    });
    
    // 丸太の生成
    gameState.logs = [];
    gameState.waterLanes.forEach(lane => {
        const count = 2 + Math.floor(Math.random() * 2);
        for (let i = 0; i < count; i++) {
            const width = config.gridSize * (2 + Math.floor(Math.random() * 3));
            let x;
            if (lane.direction > 0) {
                x = -width - Math.random() * canvasWidth * 0.5;
            } else {
                x = canvasWidth + Math.random() * canvasWidth * 0.5;
            }
            const spacing = canvasWidth / count;
            x += i * spacing;
            
            gameState.logs.push({
                x,
                y: lane.y,
                width,
                height: config.gridSize * 0.8,
                speed: lane.speed
            });
        }
    });
    
    // 電車の生成
    gameState.trains = [];
    gameState.railwayLanes.forEach(lane => {
        const count = 1 + Math.floor(Math.random() * 2); // 電車は少し少なめに
        for (let i = 0; i < count; i++) {
            const width = config.gridSize * (4 + Math.floor(Math.random() * 3)); // 車より横長に
            let x;
            if (lane.direction > 0) {
                x = -width - Math.random() * canvasWidth;
            } else {
                x = canvasWidth + Math.random() * canvasWidth;
            }
            const spacing = canvasWidth * 1.5 / count; // 電車間の間隔を広くする
            x += i * spacing;
            
            gameState.trains.push({
                x,
                y: lane.y,
                width,
                height: config.gridSize * 0.9,
                speed: lane.speed,
                color: getRandomColor(),
                type: getRandomTrainType()
            });
        }
    });
}

// 当たり判定（改善版：より精確に）
function checkCollision(rect1, rect2) {
    // スマホでも確実に当たり判定するために、余裕をより少なくする
    const margin = 5; // さらに小さい余裕値に設定
    
    return (rect1.x + margin) < (rect2.x + rect2.width - margin) &&
           (rect1.x + rect1.width - margin) > (rect2.x + margin) &&
           (rect1.y + margin) < (rect2.y + rect2.height - margin) &&
           (rect1.y + rect1.height - margin) > (rect2.y + margin);
}

// クジラの生成
function spawnWhale() {
    const now = Date.now();
    
    // 前回のクジラ出現から十分な時間が経過していて、確率条件を満たす場合
    if (now - gameState.lastWhaleTime > config.whaleInterval && Math.random() < config.whaleChance) {
        // ランダムな水レーンを選択
        const waterLane = gameState.waterLanes[Math.floor(Math.random() * gameState.waterLanes.length)];
        if (!waterLane) return;
        
        // クジラの生成
        const direction = Math.random() > 0.5 ? 1 : -1;
        const speed = direction * (config.logMinSpeed * 2);  // 丸太より少し速く
        let x = direction > 0 ? -config.gridSize * 3 : canvasWidth;
        
        gameState.whales.push({
            x,
            y: waterLane.y,
            width: config.gridSize * 3,
            height: config.gridSize,
            speed,
            animationOffset: 0
        });
        
        gameState.lastWhaleTime = now;
    }
}

// プレイヤーの更新
function updatePlayer() {
    if (gameState.isMoving) {
        // アニメーションの更新（少し速度を上げる）
        gameState.moveProgress += 0.15; // 0.1から0.15に変更して動きを速く
        
        if (gameState.moveProgress >= 1) {
            // 移動完了
            gameState.player.x = gameState.targetX;
            gameState.player.y = gameState.targetY;
            gameState.isMoving = false;
            
            // 移動完了後にゲーム状態をチェック
            checkGameState();
        } else {
            // 線形補間で移動
            const startX = gameState.player.x;
            const startY = gameState.player.y;
            gameState.player.x = startX + (gameState.targetX - startX) * gameState.moveProgress;
            gameState.player.y = startY + (gameState.targetY - startY) * gameState.moveProgress;
        }
    } else {
        // 丸太の上にいる場合は丸太の速度で横に移動
        if (gameState.isOnLog) {
            gameState.player.x += gameState.currentLogSpeed;
            
            // 丸太から落ちた場合
            if (gameState.player.x < 0 || gameState.player.x + gameState.player.width > canvasWidth) {
                gameOver();
                return;
            }
        } else {
            // 水の中にいるかチェック
            const waterLane = gameState.lanes.find(lane => 
                lane.type === 'water' && 
                Math.abs(lane.y - gameState.player.y) < config.gridSize / 2
            );
            
            if (waterLane) {
                // 水の中にいて、丸太の上でない場合はゲームオーバー
                let onAnyLog = false;
                for (const log of gameState.logs) {
                    if (checkCollision(gameState.player, log)) {
                        onAnyLog = true;
                        gameState.isOnLog = true;
                        gameState.currentLogSpeed = log.speed;
                        break;
                    }
                }
                
                if (!onAnyLog) {
                    gameOver();
                    return;
                }
            }
        }
    }
}

// ゲーム状態チェック（移動完了後）



function checkGameState() {
    // 水レーンにいるかチェック
    const waterLane = gameState.lanes.find(lane => 
        lane.type === 'water' && 
        Math.abs(lane.y - gameState.player.y) < config.gridSize / 2
    );
    
    if (waterLane) {
        // 水の中にいる場合、丸太の上にいるかチェック
        gameState.isOnLog = false;
        gameState.currentLogSpeed = 0;
        
        for (const log of gameState.logs) {
            if (checkCollision(gameState.player, log)) {
                gameState.isOnLog = true;
                gameState.currentLogSpeed = log.speed;
                break;
            }
        }
        
        // 丸太の上にいない場合はゲームオーバー
        if (!gameState.isOnLog) {
            gameOver();
            return;
        }
    } else {
        // 水レーンにいない場合はリセット
        gameState.isOnLog = false;
        gameState.currentLogSpeed = 0;
    }
    
    // ゴールに到達したかチェック
    const goalLane = gameState.lanes.find(lane => lane.type === 'goal');
    if (goalLane && Math.abs(gameState.player.y - goalLane.y) < config.gridSize / 2) {
        // スコアを加算
        gameState.score += 100;
        document.getElementById('score').textContent = `スコア: ${gameState.score}`;
        
        // 次の干支に進む
        gameState.zodiacIndex = (gameState.zodiacIndex + 1) % zodiacCharacters.length;
        document.getElementById('characterInfo').textContent = `キャラクター: ${gameState.zodiacIndex + 1}/${zodiacCharacters.length} ${zodiacCharacters[gameState.zodiacIndex].name}`;
        
        // 全干支をクリアしたらゲームクリア
        if (gameState.zodiacIndex === 0) {
            document.getElementById('completeScore').textContent = gameState.score;
            document.getElementById('gameComplete').style.display = 'block';
            gameState.isGameOver = true;
            return;
        }
        
        // プレイヤーをスタート地点に戻す
        gameState.player.x = Math.floor(canvasWidth / 2 - config.gridSize / 2);
        gameState.player.y = canvasHeight - config.gridSize * 2;
        
        // 難易度を上げる
        config.vehicleMinSpeed += 0.2;
        config.vehicleMaxSpeed += 0.2;
        config.logMinSpeed += 0.1;
        config.logMaxSpeed += 0.2;
        config.trainMinSpeed += 0.1;
        config.trainMaxSpeed += 0.3;
        config.whaleChance += 0.05;
        
        // 4体目（龍）をクリアした後、レーン数を増やす
        if (gameState.zodiacIndex === 4) {
            config.laneCount = Math.min(5, config.laneCount + 1);
            config.railwayLaneCount = Math.min(3, config.railwayLaneCount + 1);
        }
        
        // レーンを再生成
        generateLanes();
    }
}
// 車両の更新
function updateVehicles() {
    gameState.vehicles.forEach(vehicle => {
        vehicle.x += vehicle.speed;
        
        // 画面外に出たら反対側から再登場
        if (vehicle.speed > 0 && vehicle.x > canvasWidth) {
            vehicle.x = -vehicle.width;
        } else if (vehicle.speed < 0 && vehicle.x + vehicle.width < 0) {
            vehicle.x = canvasWidth;
        }
    });
}

// 丸太の更新
function updateLogs() {
    gameState.logs.forEach(log => {
        log.x += log.speed;
        
        // 画面外に出たら反対側から再登場
        if (log.speed > 0 && log.x > canvasWidth) {
            log.x = -log.width;
        } else if (log.speed < 0 && log.x + log.width < 0) {
            log.x = canvasWidth;
        }
    });
}

// 電車の更新
function updateTrains() {
    gameState.trains.forEach(train => {
        train.x += train.speed;
        
        // 画面外に出たら反対側から再登場（電車は少し間隔を空けて）
        if (train.speed > 0 && train.x > canvasWidth) {
            train.x = -train.width - Math.random() * canvasWidth * 0.3;
        } else if (train.speed < 0 && train.x + train.width < 0) {
            train.x = canvasWidth + Math.random() * canvasWidth * 0.3;
        }
    });
}

// クジラの更新
function updateWhales() {
    gameState.whales = gameState.whales.filter(whale => {
        whale.x += whale.speed;
        whale.animationOffset = (whale.animationOffset + 0.05) % (Math.PI * 2);
        
        // 画面外に出たらクジラを削除
        if ((whale.speed > 0 && whale.x > canvasWidth) || 
            (whale.speed < 0 && whale.x + whale.width < 0)) {
            return false;
        }
        return true;
    });
    
    // 新しいクジラの生成を試みる
    spawnWhale();
}

// 描画
function draw() {
    // 背景
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // レーンの描画
    gameState.lanes.forEach(lane => {
        if (lane.type === 'road') {
            ctx.fillStyle = '#555555';
            ctx.fillRect(0, lane.y, canvasWidth, config.gridSize);
            
            // 道路の白線
            ctx.strokeStyle = '#FFFFFF';
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(0, lane.y + config.gridSize / 2);
            ctx.lineTo(canvasWidth, lane.y + config.gridSize / 2);
            ctx.stroke();
            ctx.setLineDash([]);
        } else if (lane.type === 'railway') {
            // 線路の背景
            ctx.fillStyle = '#777777';
            ctx.fillRect(0, lane.y, canvasWidth, config.gridSize);
            
            // レールの描画
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, lane.y + config.gridSize * 0.3);
            ctx.lineTo(canvasWidth, lane.y + config.gridSize * 0.3);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, lane.y + config.gridSize * 0.7);
            ctx.lineTo(canvasWidth, lane.y + config.gridSize * 0.7);
            ctx.stroke();
            
            // 枕木
            ctx.fillStyle = '#8B4513';
            for (let i = 0; i < canvasWidth; i += 20) {
                ctx.fillRect(i, lane.y + config.gridSize * 0.25, 10, config.gridSize * 0.5);
            }
        } else if (lane.type === 'water') {
            ctx.fillStyle = '#4444FF';
            ctx.fillRect(0, lane.y, canvasWidth, config.gridSize);
            
            // 水の波紋
            ctx.strokeStyle = '#8888FF';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvasWidth; i += 30) {
                ctx.beginPath();
                ctx.arc(i, lane.y + config.gridSize / 2, 10, 0, Math.PI);
                ctx.stroke();
            }
        } else if (lane.type === 'safe') {
            ctx.fillStyle = '#44AA44';
            ctx.fillRect(0, lane.y, canvasWidth, config.gridSize);
            
            // 草の表現
            ctx.fillStyle = '#66CC66';
            for (let i = 0; i < canvasWidth; i += 15) {
                ctx.beginPath();
                ctx.arc(i, lane.y + config.gridSize / 2, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (lane.type === 'goal') {
            ctx.fillStyle = '#FFFF44';
            ctx.fillRect(0, lane.y, canvasWidth, config.gridSize);
            
            // ゴールのマーク
            ctx.fillStyle = '#FF9900';
            for (let i = 0; i < canvasWidth; i += 60) {
                ctx.beginPath();
                ctx.moveTo(i, lane.y);
                ctx.lineTo(i + 30, lane.y + config.gridSize);
                ctx.lineTo(i + 60, lane.y);
                ctx.fill();
            }
        }
    });
    
    // 丸太の描画
    gameState.logs.forEach(log => {
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(log.x, log.y + (config.gridSize - log.height) / 2, log.width, log.height);
        
        // 丸太の装飾
        ctx.strokeStyle = '#5D2906';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 1; i < log.width / 10; i++) {
            ctx.moveTo(log.x + i * 10, log.y + (config.gridSize - log.height) / 2);
            ctx.lineTo(log.x + i * 10, log.y + (config.gridSize - log.height) / 2 + log.height);
        }
        ctx.stroke();
    });
    
    // 電車の描画
    gameState.trains.forEach(train => {
        const dir = train.speed > 0 ? 1 : -1;
        const trainY = train.y + (config.gridSize - train.height) / 2;
        
        // 電車の種類に応じた描画
        switch(train.type) {
            case 'passenger':
                // 車体
                ctx.fillStyle = '#0066CC';
                ctx.fillRect(train.x, trainY, train.width, train.height);
                
                // 窓（複数）
                const windowCount = Math.floor(train.width / 30);
                for (let i = 0; i < windowCount; i++) {
                    ctx.fillStyle = '#AADDFF';
                    ctx.fillRect(train.x + 10 + i * 30, trainY + train.height * 0.2, 20, train.height * 0.4);
                }
                
                // 先頭部分
                ctx.fillStyle = '#003366';
                if (dir > 0) {
                    ctx.beginPath();
                    ctx.moveTo(train.x + train.width, trainY);
                    ctx.lineTo(train.x + train.width, trainY + train.height);
                    ctx.lineTo(train.x + train.width - 10, trainY + train.height);
                    ctx.lineTo(train.x + train.width - 20, trainY + train.height * 0.7);
                    ctx.lineTo(train.x + train.width - 20, trainY + train.height * 0.3);
                    ctx.lineTo(train.x + train.width - 10, trainY);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(train.x, trainY);
                    ctx.lineTo(train.x, trainY + train.height);
                    ctx.lineTo(train.x + 10, trainY + train.height);
                    ctx.lineTo(train.x + 20, trainY + train.height * 0.7);
                    ctx.lineTo(train.x + 20, trainY + train.height * 0.3);
                    ctx.lineTo(train.x + 10, trainY);
                    ctx.closePath();
                    ctx.fill();
                }
                break;
                
            case 'freight':
                // 貨物電車
                ctx.fillStyle = '#996633';
                ctx.fillRect(train.x, trainY, train.width, train.height);
                
                // コンテナの区切り
                const containerCount = Math.floor(train.width / 50);
                for (let i = 0; i < containerCount; i++) {
                    ctx.fillStyle = getRandomColor();
                    ctx.fillRect(train.x + 5 + i * 50, trainY + 5, 40, train.height - 10);
                }
                break;
                
            case 'express':
                // 特急電車
                ctx.fillStyle = '#CC0000';
                ctx.fillRect(train.x, trainY, train.width, train.height);
                
                // スピード感ある窓のデザイン
                ctx.fillStyle = '#FFDDDD';
                ctx.fillRect(train.x + 10, trainY + train.height * 0.2, train.width - 20, train.height * 0.3);
                
                // 先頭部分
                if (dir > 0) {
                    ctx.beginPath();
                    ctx.moveTo(train.x + train.width, trainY + train.height * 0.5);
                    ctx.lineTo(train.x + train.width - 30, trainY);
                    ctx.lineTo(train.x + train.width - 30, trainY + train.height);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(train.x, trainY + train.height * 0.5);
                    ctx.lineTo(train.x + 30, trainY);
                    ctx.lineTo(train.x + 30, trainY + train.height);
                    ctx.closePath();
                    ctx.fill();
                }
                break;
                
            case 'bullet':
                // 新幹線風
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(train.x, trainY, train.width, train.height);
                
                // 青いライン
                ctx.fillStyle = '#0055AA';
                ctx.fillRect(train.x, trainY + train.height * 0.6, train.width, train.height * 0.2);
                
                // 先頭部分
                if (dir > 0) {
                    ctx.beginPath();
                    ctx.moveTo(train.x + train.width, trainY + train.height * 0.5);
                    ctx.lineTo(train.x + train.width - 40, trainY);
                    ctx.lineTo(train.x + train.width - 40, trainY + train.height);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(train.x, trainY + train.height * 0.5);
                    ctx.lineTo(train.x + 40, trainY);
                    ctx.lineTo(train.x + 40, trainY + train.height);
                    ctx.closePath();
                    ctx.fill();
                }
                break;
        }
        
        // 車輪の描画
        ctx.fillStyle = '#000000';
        const wheelCount = Math.floor(train.width / 40);
        for (let i = 0; i < wheelCount; i++) {
            ctx.beginPath();
            ctx.arc(train.x + 20 + i * 40, trainY + train.height, 5, 0, Math.PI * 2);
            ctx.fill();
        }
    });
    
    // クジラの描画
    gameState.whales.forEach(whale => {
        const dir = whale.speed > 0 ? 1 : -1;
        const wY = whale.y;
        const waterOffset = Math.sin(whale.animationOffset) * 5;
        
        // クジラの体
        ctx.fillStyle = '#333399';
        ctx.beginPath();
        ctx.ellipse(
            whale.x + whale.width / 2, 
            wY + whale.height / 2 + waterOffset, 
            whale.width / 2, 
            whale.height / 2, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // クジラの尻尾
        ctx.fillStyle = '#333399';
        ctx.beginPath();
        if (dir > 0) {
            ctx.moveTo(whale.x, wY + whale.height / 2 + waterOffset);
            ctx.lineTo(whale.x - whale.width / 4, wY + whale.height / 4 + waterOffset);
            ctx.lineTo(whale.x - whale.width / 4, wY + whale.height * 3/4 + waterOffset);
        } else {
            ctx.moveTo(whale.x + whale.width, wY + whale.height / 2 + waterOffset);
            ctx.lineTo(whale.x + whale.width + whale.width / 4, wY + whale.height / 4 + waterOffset);
            ctx.lineTo(whale.x + whale.width + whale.width / 4, wY + whale.height * 3/4 + waterOffset);
        }
        ctx.closePath();
        ctx.fill();
        
        // クジラの目
        ctx.fillStyle = '#FFFFFF';
        const eyeX = dir > 0 ? 
            whale.x + whale.width * 3/4 : 
            whale.x + whale.width * 1/4;
        ctx.beginPath();
        ctx.arc(eyeX, wY + whale.height / 3 + waterOffset, whale.width / 15, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(eyeX, wY + whale.height / 3 + waterOffset, whale.width / 25, 0, Math.PI * 2);
        ctx.fill();
        
        // 水しぶき
        ctx.fillStyle = '#AADDFF';
        const spoutX = dir > 0 ? 
            whale.x + whale.width * 2/3 : 
            whale.x + whale.width * 1/3;
        ctx.beginPath();
        ctx.moveTo(spoutX, wY + waterOffset);
        ctx.lineTo(spoutX - 5, wY - 20 + waterOffset);
        ctx.lineTo(spoutX + 5, wY - 20 + waterOffset);
        ctx.closePath();
        ctx.fill();
    });
    
    // 車両の描画
    gameState.vehicles.forEach(vehicle => {
        // 車体の描画
        ctx.fillStyle = vehicle.color;
        ctx.fillRect(vehicle.x, vehicle.y + (config.gridSize - vehicle.height) / 2, vehicle.width, vehicle.height);
        
        // 車種によって異なる描画
        const dir = vehicle.speed > 0 ? 1 : -1;
        const vY = vehicle.y + (config.gridSize - vehicle.height) / 2;
        
        switch(vehicle.type) {
            case 'sedan':
                // 窓
                ctx.fillStyle = '#AADDFF';
                ctx.fillRect(vehicle.x + vehicle.width * (dir > 0 ? 0.6 : 0.1), vY + vehicle.height * 0.2, vehicle.width * 0.3, vehicle.height * 0.4);
                
                // タイヤ
                ctx.fillStyle = '#000000';
                ctx.fillRect(vehicle.x + vehicle.width * 0.1, vY + vehicle.height * 0.8, vehicle.width * 0.15, vehicle.height * 0.2);
                ctx.fillRect(vehicle.x + vehicle.width * 0.7, vY + vehicle.height * 0.8, vehicle.width * 0.15, vehicle.height * 0.2);
                break;
                
            case 'suv':
                // 窓（前後）
                ctx.fillStyle = '#AADDFF';
                ctx.fillRect(vehicle.x + vehicle.width * (dir > 0 ? 0.5 : 0.1), vY + vehicle.height * 0.15, vehicle.width * 0.25, vehicle.height * 0.4);
                ctx.fillRect(vehicle.x + vehicle.width * (dir > 0 ? 0.15 : 0.6), vY + vehicle.height * 0.15, vehicle.width * 0.25, vehicle.height * 0.4);
                
                // タイヤ（大きめ）
                ctx.fillStyle = '#000000';
                ctx.fillRect(vehicle.x + vehicle.width * 0.1, vY + vehicle.height * 0.75, vehicle.width * 0.2, vehicle.height * 0.25);
                ctx.fillRect(vehicle.x + vehicle.width * 0.7, vY + vehicle.height * 0.75, vehicle.width * 0.2, vehicle.height * 0.25);
                break;
                
            case 'truck':
                // 運転席とトラック荷台の分離
                ctx.fillStyle = vehicle.color;
                ctx.fillRect(vehicle.x + (dir > 0 ? 0 : vehicle.width * 0.3), vY + vehicle.height * 0.1, vehicle.width * 0.3, vehicle.height * 0.6);
                
                // 窓
                ctx.fillStyle = '#AADDFF';
                ctx.fillRect(vehicle.x + (dir > 0 ? 0.05 : 0.35) * vehicle.width, vY + vehicle.height * 0.15, vehicle.width * 0.2, vehicle.height * 0.3);
                
                // タイヤ（小・大）
                ctx.fillStyle = '#000000';
                ctx.fillRect(vehicle.x + vehicle.width * (dir > 0 ? 0.1 : 0.35), vY + vehicle.height * 0.7, vehicle.width * 0.15, vehicle.height * 0.3);
                ctx.fillRect(vehicle.x + vehicle.width * (dir > 0 ? 0.6 : 0.1), vY + vehicle.height * 0.7, vehicle.width * 0.25, vehicle.height * 0.3);
                break;
                
            case 'bus':
                // 長い車体
                ctx.fillStyle = vehicle.color;
                
                // 多くの窓
                ctx.fillStyle = '#AADDFF';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(vehicle.x + vehicle.width * (0.2 + i * 0.2), vY + vehicle.height * 0.15, vehicle.width * 0.15, vehicle.height * 0.3);
                }
                
                // タイヤ（前後）
                ctx.fillStyle = '#000000';
                ctx.fillRect(vehicle.x + vehicle.width * 0.1, vY + vehicle.height * 0.75, vehicle.width * 0.15, vehicle.height * 0.25);
                ctx.fillRect(vehicle.x + vehicle.width * 0.7, vY + vehicle.height * 0.75, vehicle.width * 0.15, vehicle.height * 0.25);
                break;
        }
    });
    
    // 干支キャラクターの描画
    drawZodiacCharacter();
}

// 干支キャラクターを描画する関数
function drawZodiacCharacter() {
    const px = gameState.player.x;
    const py = gameState.player.y;
    const pw = gameState.player.width;
    const ph = gameState.player.height;
    
    // アニメーション用の動きを追加
    const bounce = Math.sin(Date.now() / 200) * 2;
    
    // 現在の干支に基づいて描画を切り替える
    const character = zodiacCharacters[gameState.zodiacIndex];
    
    switch(gameState.zodiacIndex) {
        case 0: // ネズミ
            // 体（楕円形）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph/2 + bounce, pw/2 * 0.8, ph/2 * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/3 + bounce, pw/2 * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // 耳
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/3, py + ph/5 + bounce, pw/10, ph/6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(px + pw*2/3, py + ph/5 + bounce, pw/10, ph/6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw/3, py + ph/3 + bounce, pw/20, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*2/3, py + ph/3 + bounce, pw/20, 0, Math.PI * 2);
            ctx.fill();
            
            // 鼻
            ctx.fillStyle = '#FF9999';
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2.5 + bounce, pw/25, 0, Math.PI * 2);
            ctx.fill();
            
            // ヒゲ
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            
            // 左ヒゲ
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph/2.5 + bounce);
            ctx.lineTo(px + pw/5, py + ph/3 + bounce);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph/2.5 + bounce);
            ctx.lineTo(px + pw/5, py + ph/2.2 + bounce);
            ctx.stroke();
            
            // 右ヒゲ
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph/2.5 + bounce);
            ctx.lineTo(px + pw*4/5, py + ph/3 + bounce);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph/2.5 + bounce);
            ctx.lineTo(px + pw*4/5, py + ph/2.2 + bounce);
            ctx.stroke();
            
            // 尻尾（長い）
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph*0.85 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.7, py + ph*0.9 + bounce,
                px + pw*0.9, py + ph*0.6 + bounce,
                px + pw*1.1, py + ph*0.7 + bounce
            );
            ctx.stroke();
            break;
            
        case 1: // 牛
            // 体（大きめの楕円）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph/2 + bounce, pw/2 * 0.9, ph/2 * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/3 + bounce, pw/2 * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // 角
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(px + pw/3, py + ph/6 + bounce);
            ctx.lineTo(px + pw/6, py - ph/10 + bounce);
            ctx.lineTo(px + pw/4, py + ph/8 + bounce);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*2/3, py + ph/6 + bounce);
            ctx.lineTo(px + pw*5/6, py - ph/10 + bounce);
            ctx.lineTo(px + pw*3/4, py + ph/8 + bounce);
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw/3, py + ph/3 + bounce, pw/20, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*2/3, py + ph/3 + bounce, pw/20, 0, Math.PI * 2);
            ctx.fill();
            
            // 鼻
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2.5 + bounce, pw/15, 0, Math.PI * 2);
            ctx.fill();
            
            // 鼻筋
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph/2.5 - pw/15 + bounce);
            ctx.lineTo(px + pw/2, py + ph/2.5 + pw/15 + bounce);
            ctx.stroke();
            
            // 口
            ctx.strokeStyle = '#6B2D0F';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2.2 + bounce, pw/15, 0.2, 0.8 * Math.PI);
            ctx.stroke();
            
            // 足
            ctx.fillStyle = character.color;
            ctx.fillRect(px + pw/4, py + ph*0.7 + bounce, pw/6, ph/4);
            ctx.fillRect(px + pw*3/5, py + ph*0.7 + bounce, pw/6, ph/4);
            
            // 尻尾
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph*0.8 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.5, py + ph*0.9 + bounce,
                px + pw*0.7, py + ph*0.9 + bounce,
                px + pw*0.8, py + ph*0.7 + bounce
            );
            ctx.stroke();
            break;
            
        case 2: // トラ
            // 体（楕円形）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph/2 + bounce, pw/2 * 0.8, ph/2 * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 縞模様
            ctx.fillStyle = '#000000';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.rect(px + pw*0.25 + i*(pw*0.1), py + ph*0.3 + bounce, pw*0.05, ph*0.4);
                ctx.fill();
            }
            
            // 頭
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/3 + bounce, pw/2 * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭の縞
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.3, py + ph*0.2 + bounce);
            ctx.lineTo(px + pw*0.4, py + ph*0.1 + bounce);
            ctx.lineTo(px + pw*0.45, py + ph*0.2 + bounce);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.7, py + ph*0.2 + bounce);
            ctx.lineTo(px + pw*0.6, py + ph*0.1 + bounce);
            ctx.lineTo(px + pw*0.55, py + ph*0.2 + bounce);
            ctx.fill();
            
            // 耳（三角形）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.moveTo(px + pw/4, py + ph/5 + bounce);
            ctx.lineTo(px + pw/6, py - ph/10 + bounce);
            ctx.lineTo(px + pw/3, py + ph/10 + bounce);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*3/4, py + ph/5 + bounce);
            ctx.lineTo(px + pw*5/6, py - ph/10 + bounce);
            ctx.lineTo(px + pw*2/3, py + ph/10 + bounce);
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath();
            ctx.arc(px + pw/3, py + ph/3 + bounce, pw/15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*2/3, py + ph/3 + bounce, pw/15, 0, Math.PI * 2);
            ctx.fill();
            
            // 瞳孔
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(px + pw/3, py + ph/3 + bounce, pw/40, ph/25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(px + pw*2/3, py + ph/3 + bounce, pw/40, ph/25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 鼻
            ctx.fillStyle = '#FF9999';
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2.5 + bounce, pw/25, 0, Math.PI * 2);
            ctx.fill();
            
            // 口
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph/2.5 + bounce);
            ctx.lineTo(px + pw/2, py + ph/2.2 + bounce);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2.1 + bounce, pw/20, 0, Math.PI);
            ctx.stroke();
            
            // 尻尾（長い）
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(px + pw/2, py + ph*0.8 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.6, py + ph*0.9 + bounce,
                px + pw*0.9, py + ph*0.7 + bounce,
                px + pw*1.1, py + ph*0.6 + bounce
            );
            ctx.stroke();
            
            // 尻尾の縞
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.7, py + ph*0.85 + bounce);
            ctx.lineTo(px + pw*0.75, py + ph*0.8 + bounce);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.9, py + ph*0.7 + bounce);
            ctx.lineTo(px + pw*0.95, py + ph*0.65 + bounce);
            ctx.stroke();
            break;
            
        case 3: // ウサギ
            // 体（丸い形）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2 + bounce, pw/2 * 0.8, 0, Math.PI * 2);
            ctx.fill();
            
            // 影をつける
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph - 5, pw/2 * 0.7, ph/4 * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2 - ph/6 + bounce, pw/2 * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // 耳
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/3, py + ph/5 - 5 + bounce, pw/10, ph/3, -0.2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(px + pw*2/3, py + ph/5 - 5 + bounce, pw/10, ph/3, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // 耳の内側（ピンク）
            ctx.fillStyle = '#FFCCE5';
            ctx.beginPath();
            ctx.ellipse(px + pw/3, py + ph/5 + bounce, pw/15, ph/4, -0.2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(px + pw*2/3, py + ph/5 + bounce, pw/15, ph/4, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw/3, py + ph/2 - ph/10 + bounce, pw/15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*2/3, py + ph/2 - ph/10 + bounce, pw/15, 0, Math.PI * 2);
            ctx.fill();
            
            // 光の反射（目の中の白い部分）
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(px + pw/3 + 2, py + ph/2 - ph/10 - 2 + bounce, pw/40, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*2/3 + 2, py + ph/2 - ph/10 - 2 + bounce, pw/40, 0, Math.PI * 2);
            ctx.fill();
            
            // 鼻
            ctx.fillStyle = '#FFADEE';
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2 + bounce, pw/15, 0, Math.PI * 2);
            ctx.fill();
            
            // 頬（ピンク）
            ctx.fillStyle = 'rgba(255,182,193,0.5)';
            ctx.beginPath();
            ctx.arc(px + pw/4, py + ph/2 + ph/15 + bounce, pw/10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*3/4, py + ph/2 + ph/15 + bounce, pw/10, 0, Math.PI * 2);
            ctx.fill();
            
            // 口
            ctx.strokeStyle = '#FF9999';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph/2 + ph/10 + bounce, pw/15, 0.2, 0.8 * Math.PI);
            ctx.stroke();
            
            // 手足
            const legOffset = gameState.isMoving ? Math.sin(gameState.moveProgress * Math.PI * 2) * 5 : 0;
            
            // 前足
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.arc(px + pw/3 - 3 + legOffset, py + ph*2/3 + 5 + bounce, pw/12, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*2/3 + 3 - legOffset, py + ph*2/3 + 5 + bounce, pw/12, 0, Math.PI * 2);
            ctx.fill();
            
            // 後ろ足
            ctx.beginPath();
            ctx.arc(px + pw/3 - 3 - legOffset, py + ph - 5 + bounce, pw/10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*2/3 + 3 + legOffset, py + ph - 5 + bounce, pw/10, 0, Math.PI * 2);
            ctx.fill();
            
            // 尻尾
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph - 5 + bounce/2, pw/8, 0, Math.PI * 2);
            ctx.fill();
            break;
            
        case 4: // 竜（龍）
            // 体（細長い楕円）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph/2 + bounce, pw/2 * 0.8, ph/2 * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 鱗模様
            ctx.strokeStyle = '#004400';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(px + pw*0.3 + i*(pw*0.1), py + ph*0.5 + bounce, pw*0.05, 0, Math.PI);
                ctx.stroke();
            }
            
            // 頭（三角形に近い形）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.2, py + ph*0.3 + bounce);
            ctx.lineTo(px + pw*0.8, py + ph*0.3 + bounce);
            ctx.lineTo(px + pw*0.5, py + ph*0.1 + bounce);
            ctx.closePath();
            ctx.fill();
            
            // 角
            ctx.fillStyle = '#008800';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.4, py + ph*0.2 + bounce);
            ctx.lineTo(px + pw*0.2, py - ph*0.1 + bounce);
            ctx.lineTo(px + pw*0.3, py + ph*0.15 + bounce);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.6, py + ph*0.2 + bounce);
            ctx.lineTo(px + pw*0.8, py - ph*0.1 + bounce);
            ctx.lineTo(px + pw*0.7, py + ph*0.15 + bounce);
            ctx.fill();
            
            // 目（赤い）
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(px + pw*0.35, py + ph*0.25 + bounce, pw/20, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*0.65, py + ph*0.25 + bounce, pw/20, 0, Math.PI * 2);
            ctx.fill();
            
            // 瞳孔（細い）
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(px + pw*0.35, py + ph*0.25 + bounce, pw/80, ph/30, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(px + pw*0.65, py + ph*0.25 + bounce, pw/80, ph/30, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 口（牙付き）
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.35, py + ph*0.35 + bounce);
            ctx.lineTo(px + pw*0.65, py + ph*0.35 + bounce);
            ctx.lineTo(px + pw*0.5, py + ph*0.45 + bounce);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.4, py + ph*0.35 + bounce);
            ctx.lineTo(px + pw*0.35, py + ph*0.4 + bounce);
            ctx.lineTo(px + pw*0.38, py + ph*0.35 + bounce);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.6, py + ph*0.35 + bounce);
            ctx.lineTo(px + pw*0.65, py + ph*0.4 + bounce);
            ctx.lineTo(px + pw*0.62, py + ph*0.35 + bounce);
            ctx.fill();
            
            // 尻尾（長く曲がった）
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.5, py + ph*0.8 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.8, py + ph*0.9 + bounce,
                px + pw*1.1, py + ph*0.7 + bounce,
                px + pw*1.0, py + ph*0.5 + bounce
            );
            ctx.stroke();
            
            // 足（鋭い爪）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.3, py + ph*0.6 + bounce);
            ctx.lineTo(px + pw*0.2, py + ph*0.9 + bounce);
            ctx.lineTo(px + pw*0.25, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.3, py + ph*0.9 + bounce);
            ctx.lineTo(px + pw*0.35, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.4, py + ph*0.9 + bounce);
            ctx.lineTo(px + pw*0.4, py + ph*0.6 + bounce);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.7, py + ph*0.6 + bounce);
            ctx.lineTo(px + pw*0.6, py + ph*0.9 + bounce);
            ctx.lineTo(px + pw*0.65, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.7, py + ph*0.9 + bounce);
            ctx.lineTo(px + pw*0.75, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.8, py + ph*0.9 + bounce);
            ctx.lineTo(px + pw*0.8, py + ph*0.6 + bounce);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 5: // 蛇
            // 体（S字型）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.2, py + ph*0.8 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.1, py + ph*0.6 + bounce,
                px + pw*0.3, py + ph*0.4 + bounce,
                px + pw*0.5, py + ph*0.3 + bounce
            );
            ctx.bezierCurveTo(
                px + pw*0.7, py + ph*0.2 + bounce,
                px + pw*0.9, py + ph*0.4 + bounce,
                px + pw*0.8, py + ph*0.6 + bounce
            );
            ctx.bezierCurveTo(
                px + pw*0.7, py + ph*0.8 + bounce,
                px + pw*0.5, py + ph*0.9 + bounce,
                px + pw*0.2, py + ph*0.8 + bounce
            );
            ctx.fill();
            
            // 鱗模様
            ctx.strokeStyle = '#AA8855';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(px + pw*0.2 + i*(pw*0.08), py + ph*0.6 - i*(ph*0.04) + bounce, pw*0.03, 0, Math.PI);
                ctx.stroke();
            }
            
            // 頭
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw*0.8, py + ph*0.3 + bounce, pw*0.15, ph*0.1, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 目（細い）
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(px + pw*0.85, py + ph*0.28 + bounce, pw/50, ph/25, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 舌（二股）
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.95, py + ph*0.3 + bounce);
            ctx.lineTo(px + pw*1.05, py + ph*0.25 + bounce);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.95, py + ph*0.3 + bounce);
            ctx.lineTo(px + pw*1.05, py + ph*0.35 + bounce);
            ctx.stroke();
            break;
            
        case 6: // 馬
            // 体（楕円形）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph*0.6 + bounce, pw*0.4, ph*0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭（長い形）
            ctx.beginPath();
            ctx.ellipse(px + pw*0.25, py + ph*0.3 + bounce, pw*0.2, ph*0.15, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 首
            ctx.beginPath();
            ctx.moveTo(px + pw*0.3, py + ph*0.4 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.2, py + ph*0.5 + bounce,
                px + pw*0.3, py + ph*0.55 + bounce,
                px + pw*0.35, py + ph*0.6 + bounce
            );
            ctx.lineTo(px + pw*0.45, py + ph*0.5 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.4, py + ph*0.45 + bounce,
                px + pw*0.35, py + ph*0.4 + bounce,
                px + pw*0.3, py + ph*0.4 + bounce
            );
            ctx.fill();
            
            // 耳
            ctx.beginPath();
            ctx.moveTo(px + pw*0.15, py + ph*0.2 + bounce);
            ctx.lineTo(px + pw*0.1, py + ph*0.1 + bounce);
            ctx.lineTo(px + pw*0.2, py + ph*0.15 + bounce);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.3, py + ph*0.2 + bounce);
            ctx.lineTo(px + pw*0.35, py + ph*0.1 + bounce);
            ctx.lineTo(px + pw*0.25, py + ph*0.15 + bounce);
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(px + pw*0.2, py + ph*0.25 + bounce, pw/30, ph/25, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 口
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.1, py + ph*0.35 + bounce);
            ctx.lineTo(px + pw*0.15, py + ph*0.37 + bounce);
            ctx.stroke();
            
            // たてがみ
            ctx.fillStyle = '#000000';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.rect(px + pw*0.3 - i*pw*0.03, py + ph*0.15 + i*ph*0.04 + bounce, pw*0.02, ph*0.08);
                ctx.fill();
            }
            
            // 足
            const horseOffset = gameState.isMoving ? Math.sin(gameState.moveProgress * Math.PI * 2) * 5 : 0;
            
            ctx.fillStyle = character.color;
            ctx.fillRect(px + pw*0.3 - horseOffset*0.03, py + ph*0.6 + bounce, pw*0.05, ph*0.3);
            ctx.fillRect(px + pw*0.45 + horseOffset*0.03, py + ph*0.6 + bounce, pw*0.05, ph*0.3);
            ctx.fillRect(px + pw*0.65 - horseOffset*0.03, py + ph*0.6 + bounce, pw*0.05, ph*0.3);
            ctx.fillRect(px + pw*0.8 + horseOffset*0.03, py + ph*0.6 + bounce, pw*0.05, ph*0.3);
            
            // 尻尾
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.9, py + ph*0.5 + bounce);
            ctx.bezierCurveTo(
                px + pw*1.0, py + ph*0.4 + bounce,
                px + pw*1.1, py + ph*0.5 + bounce,
                px + pw*1.0, py + ph*0.7 + bounce
            );
            ctx.bezierCurveTo(
                px + pw*0.95, py + ph*0.6 + bounce,
                px + pw*0.9, py + ph*0.55 + bounce,
                px + pw*0.9, py + ph*0.5 + bounce
            );
            ctx.fill();
            break;
            
        case 7: // 羊
            // 体（丸い楕円）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph*0.6 + bounce, pw*0.4, ph*0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // もこもこの毛
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(px + pw*0.3 + i*pw*0.06, py + ph*0.4 + (i%2)*ph*0.05 + bounce, pw*0.08, 0, Math.PI * 2);
                ctx.fill();
            }
            
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(px + pw*0.3 + i*pw*0.06, py + ph*0.5 + ((i+1)%2)*ph*0.05 + bounce, pw*0.08, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 頭
            ctx.beginPath();
            ctx.arc(px + pw*0.3, py + ph*0.35 + bounce, pw*0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // 顔（少し暗い色）
            ctx.fillStyle = '#EEEECC';
            ctx.beginPath();
            ctx.arc(px + pw*0.28, py + ph*0.32 + bounce, pw*0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // 角（渦巻き）
            ctx.fillStyle = '#BBAA99';
            ctx.beginPath();
            ctx.arc(px + pw*0.2, py + ph*0.2 + bounce, pw*0.05, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*0.4, py + ph*0.2 + bounce, pw*0.05, 0, Math.PI * 2);
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw*0.25, py + ph*0.3 + bounce, pw/25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*0.35, py + ph*0.3 + bounce, pw/25, 0, Math.PI * 2);
            ctx.fill();
            
            // 口
            ctx.strokeStyle = '#888888';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(px + pw*0.3, py + ph*0.35 + bounce, pw/20, 0, Math.PI);
            ctx.stroke();
            
            // 足
            const sheepOffset = gameState.isMoving ? Math.sin(gameState.moveProgress * Math.PI * 2) * 5 : 0;
            
            ctx.fillStyle = '#DDDDCC';
            ctx.fillRect(px + pw*0.35 - sheepOffset*0.03, py + ph*0.7 + bounce, pw*0.05, ph*0.25);
            ctx.fillRect(px + pw*0.5 + sheepOffset*0.03, py + ph*0.7 + bounce, pw*0.05, ph*0.25);
            ctx.fillRect(px + pw*0.65 - sheepOffset*0.03, py + ph*0.7 + bounce, pw*0.05, ph*0.25);
            ctx.fillRect(px + pw*0.8 + sheepOffset*0.03, py + ph*0.7 + bounce, pw*0.05, ph*0.25);
            break;
            
        case 8: // サル
            // 体（小さめの楕円）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph*0.6 + bounce, pw*0.25, ph*0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭（大きめの円）
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph*0.3 + bounce, pw*0.25, 0, Math.PI * 2);
            ctx.fill();
            
            // 顔（少し明るい色）
            ctx.fillStyle = '#FFDDBB';
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph*0.32 + bounce, pw*0.2, ph*0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 耳（丸い）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.arc(px + pw*0.3, py + ph*0.15 + bounce, pw*0.1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*0.7, py + ph*0.15 + bounce, pw*0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw*0.4, py + ph*0.25 + bounce, pw/20, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*0.6, py + ph*0.25 + bounce, pw/20, 0, Math.PI * 2);
            ctx.fill();
            
            // 鼻
            ctx.fillStyle = '#FF9999';
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph*0.35 + bounce, pw/25, 0, Math.PI * 2);
            ctx.fill();
            
            // 口
            ctx.strokeStyle = '#AA6633';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(px + pw/2, py + ph*0.4 + bounce, pw/15, 0, Math.PI);
            ctx.stroke();
            
            // 腕と足
            const monkeyOffset = gameState.isMoving ? Math.sin(gameState.moveProgress * Math.PI * 2) * 5 : 0;
            
            // 腕
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.3, py + ph*0.5 + bounce);
            ctx.lineTo(px + pw*0.15 - monkeyOffset*0.03, py + ph*0.6 + bounce);
            ctx.lineTo(px + pw*0.2, py + ph*0.65 + bounce);
            ctx.lineTo(px + pw*0.35, py + ph*0.55 + bounce);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.7, py + ph*0.5 + bounce);
            ctx.lineTo(px + pw*0.85 + monkeyOffset*0.03, py + ph*0.6 + bounce);
            ctx.lineTo(px + pw*0.8, py + ph*0.65 + bounce);
            ctx.lineTo(px + pw*0.65, py + ph*0.55 + bounce);
            ctx.closePath();
            ctx.fill();
            
            // 足
            ctx.beginPath();
            ctx.moveTo(px + pw*0.4, py + ph*0.75 + bounce);
            ctx.lineTo(px + pw*0.35 - monkeyOffset*0.03, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.4, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.45, py + ph*0.8 + bounce);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.6, py + ph*0.75 + bounce);
            ctx.lineTo(px + pw*0.65 + monkeyOffset*0.03, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.6, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.55, py + ph*0.8 + bounce);
            ctx.closePath();
            ctx.fill();
            
            // 尻尾（長く曲がった）
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.5, py + ph*0.75 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.6, py + ph*0.9 + bounce,
                px + pw*0.9, py + ph*0.85 + bounce,
                px + pw*0.9, py + ph*0.6 + bounce
            );
            ctx.stroke();
            break;
            
        case 9: // 鳥（酉）
            // 体（卵形）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph*0.6 + bounce, pw*0.3, ph*0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭
            ctx.beginPath();
            ctx.arc(px + pw*0.6, py + ph*0.3 + bounce, pw*0.18, 0, Math.PI * 2);
            ctx.fill();
            
            // トサカ
            ctx.fillStyle = '#FF3333';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.5, py + ph*0.15 + bounce);
            ctx.lineTo(px + pw*0.6, py + bounce);
            ctx.lineTo(px + pw*0.7, py + ph*0.15 + bounce);
            ctx.fill();
            
            // くちばし
            ctx.fillStyle = '#FFAA00';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.75, py + ph*0.3 + bounce);
            ctx.lineTo(px + pw*0.9, py + ph*0.35 + bounce);
            ctx.lineTo(px + pw*0.75, py + ph*0.4 + bounce);
            ctx.closePath();
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw*0.7, py + ph*0.25 + bounce, pw/25, 0, Math.PI * 2);
            ctx.fill();
            
            // 羽（翼）
            ctx.fillStyle = '#FF9999';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.3, py + ph*0.5 + bounce);
            ctx.lineTo(px + pw*0.1, py + ph*0.6 + bounce);
            ctx.lineTo(px + pw*0.1, py + ph*0.7 + bounce);
            ctx.lineTo(px + pw*0.3, py + ph*0.65 + bounce);
            ctx.closePath();
            ctx.fill();
            
            // 足
            const birdOffset = gameState.isMoving ? Math.sin(gameState.moveProgress * Math.PI * 2) * 5 : 0;
            
            ctx.fillStyle = '#FFAA00';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.4, py + ph*0.85 + bounce);
            ctx.lineTo(px + pw*0.35 - birdOffset*0.03, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.4, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.45, py + ph*0.85 + bounce);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.6, py + ph*0.85 + bounce);
            ctx.lineTo(px + pw*0.55 + birdOffset*0.03, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.6, py + ph*0.95 + bounce);
            ctx.lineTo(px + pw*0.65, py + ph*0.85 + bounce);
            ctx.closePath();
            ctx.fill();
            
            // 尾羽
            ctx.fillStyle = character.color;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.ellipse(
                    px + pw*0.3, 
                    py + ph*0.5 + i*ph*0.05 + bounce, 
                    pw*0.1, 
                    ph*0.05, 
                    -0.3, 
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            break;
            
        case 10: // 犬
            // 体（楕円）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph*0.7 + bounce, pw*0.35, ph*0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭
            ctx.beginPath();
            ctx.arc(px + pw*0.25, py + ph*0.45 + bounce, pw*0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // 耳（三角形）
            ctx.beginPath();
            ctx.moveTo(px + pw*0.1, py + ph*0.3 + bounce);
            ctx.lineTo(px + pw*0.05, py + ph*0.1 + bounce);
            ctx.lineTo(px + pw*0.2, py + ph*0.25 + bounce);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(px + pw*0.4, py + ph*0.3 + bounce);
            ctx.lineTo(px + pw*0.45, py + ph*0.1 + bounce);
            ctx.lineTo(px + pw*0.3, py + ph*0.25 + bounce);
            ctx.fill();
            
            // 目
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw*0.2, py + ph*0.4 + bounce, pw/30, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(px + pw*0.3, py + ph*0.4 + bounce, pw/30, 0, Math.PI * 2);
            ctx.fill();
            
            // 鼻
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw*0.25, py + ph*0.48 + bounce, pw/25, 0, Math.PI * 2);
            ctx.fill();
            
            // 口
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.25, py + ph*0.48 + bounce);
            ctx.lineTo(px + pw*0.25, py + ph*0.53 + bounce);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(px + pw*0.25, py + ph*0.53 + bounce, pw/15, 0, Math.PI);
            ctx.stroke();
            
            // 足
            const dogOffset = gameState.isMoving ? Math.sin(gameState.moveProgress * Math.PI * 2) * 5 : 0;
            
            ctx.fillStyle = character.color;
            ctx.fillRect(px + pw*0.3 - dogOffset*0.03, py + ph*0.75 + bounce, pw*0.05, ph*0.2);
            ctx.fillRect(px + pw*0.45 + dogOffset*0.03, py + ph*0.75 + bounce, pw*0.05, ph*0.2);
            ctx.fillRect(px + pw*0.6 - dogOffset*0.03, py + ph*0.75 + bounce, pw*0.05, ph*0.2);
            ctx.fillRect(px + pw*0.75 + dogOffset*0.03, py + ph*0.75 + bounce, pw*0.05, ph*0.2);
            
            // 尻尾（巻いた）
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.8, py + ph*0.65 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.9, py + ph*0.6 + bounce,
                px + pw*1.0, py + ph*0.7 + bounce,
                px + pw*0.95, py + ph*0.5 + bounce
            );
            ctx.stroke();
            break;
            
        case 11: // イノシシ
            // 体（大きめの楕円）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph*0.6 + bounce, pw*0.4, ph*0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 頭（三角形に近い形）
            ctx.beginPath();
            ctx.moveTo(px + pw*0.1, py + ph*0.4 + bounce);
            ctx.lineTo(px + pw*0.4, py + ph*0.2 + bounce);
            ctx.lineTo(px + pw*0.4, py + ph*0.6 + bounce);
            ctx.closePath();
            ctx.fill();
            
            // 目（小さい）
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px + pw*0.25, py + ph*0.35 + bounce, pw/40, 0, Math.PI * 2);
            ctx.fill();
            
            // 鼻（楕円）
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(px + pw*0.15, py + ph*0.4 + bounce, pw*0.05, ph*0.03, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 牙
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(px + pw*0.18, py + ph*0.45 + bounce);
            ctx.lineTo(px + pw*0.1, py + ph*0.4 + bounce);
            ctx.lineTo(px + pw*0.15, py + ph*0.5 + bounce);
            ctx.fill();
            
            // 耳（小さい三角形）
            ctx.fillStyle = character.color;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.35, py + ph*0.25 + bounce);
            ctx.lineTo(px + pw*0.3, py + ph*0.15 + bounce);
            ctx.lineTo(px + pw*0.4, py + ph*0.2 + bounce);
            ctx.fill();
            
            // 足
            const boarOffset = gameState.isMoving ? Math.sin(gameState.moveProgress * Math.PI * 2) * 5 : 0;
            
            ctx.fillStyle = character.color;
            ctx.fillRect(px + pw*0.25 - boarOffset*0.03, py + ph*0.7 + bounce, pw*0.05, ph*0.25);
            ctx.fillRect(px + pw*0.4 + boarOffset*0.03, py + ph*0.7 + bounce, pw*0.05, ph*0.25);
            ctx.fillRect(px + pw*0.65 - boarOffset*0.03, py + ph*0.7 + bounce, pw*0.05, ph*0.25);
            ctx.fillRect(px + pw*0.8 + boarOffset*0.03, py + ph*0.7 + bounce, pw*0.05, ph*0.25);
            
            // 尻尾（短くカール）
            ctx.strokeStyle = character.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(px + pw*0.9, py + ph*0.55 + bounce);
            ctx.bezierCurveTo(
                px + pw*0.95, py + ph*0.5 + bounce,
                px + pw*1.0, py + ph*0.55 + bounce,
                px + pw*0.98, py + ph*0.45 + bounce
            );
            ctx.stroke();
            break;
    }
}

// ゲームオーバー処理
function gameOver() {
    gameState.isGameOver = true;
    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
    }
    
    document.getElementById('finalScore').textContent = gameState.score;
    document.getElementById('gameOver').style.display = 'block';
}

// リスタート処理
function restart() {
    gameState.isGameOver = false;
    gameState.score = 0;
    document.getElementById('score').textContent = `スコア: 0`;
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('gameComplete').style.display = 'none';
    
    // 設定を初期値に戻す
    config.vehicleMinSpeed = 1;
    config.vehicleMaxSpeed = 2;
    config.logMinSpeed = 1;
    config.logMaxSpeed = 3;
    config.trainMinSpeed = 2;
    config.trainMaxSpeed = 3;
    config.whaleChance = 0.3;
    
    // レーン数も初期値に戻す
    config.laneCount = 3;
    config.railwayLaneCount = 2;
    
    // 干支をネズミに戻す
    gameState.zodiacIndex = 0;
    document.getElementById('characterInfo').textContent = `キャラクター: ${gameState.zodiacIndex + 1}/${zodiacCharacters.length} ${zodiacCharacters[gameState.zodiacIndex].name}`;
    
    // プレイヤーをスタート地点に戻す
    gameState.player.x = Math.floor(canvasWidth / 2 - config.gridSize / 2);
    gameState.player.y = canvasHeight - config.gridSize * 2;
    
    // 移動関連のリセット
    gameState.isMoving = false;
    gameState.direction = null;
    gameState.whales = [];
    gameState.lastWhaleTime = 0;
    
    // 丸太に関する状態を確実にリセット
    gameState.isOnLog = false;
    gameState.currentLogSpeed = 0;
    
    generateLanes();
}

document.getElementById('restartBtn').addEventListener('click', restart);

// メインループ
function gameLoop() {
    if (!gameState.isGameOver) {
        updateVehicles();
        updateLogs();
        updateTrains(); // 電車の更新を追加
        updateWhales();
        updatePlayer();
        
        // プレイヤーが移動中でなくても車両との衝突判定を毎フレーム行う
        if (!gameState.isMoving) {
            // 車との衝突判定
            for (const vehicle of gameState.vehicles) {
                if (checkCollision(gameState.player, vehicle)) {
                    gameOver();
                    break;
                }
            }
            
            // 電車との衝突判定
            for (const train of gameState.trains) {
                if (checkCollision(gameState.player, train)) {
                    gameOver();
                    break;
                }
            }
            
            // クジラとの衝突判定
            for (const whale of gameState.whales) {
                if (checkCollision(gameState.player, whale)) {
                    gameOver();
                    break;
                }
            }
        }
    }
    
    draw();
    requestAnimationFrame(gameLoop);
}
// ゲーム開始
function initGame() {
    generateLanes();
    // 干支表示の初期化
    document.getElementById('characterInfo').textContent = `キャラクター: ${gameState.zodiacIndex + 1}/${zodiacCharacters.length} ${zodiacCharacters[gameState.zodiacIndex].name}`;
    gameLoop();
}   

// ゲーム開始
initGame();
generateLanes();
gameLoop();    </script>
</body>
</html>
